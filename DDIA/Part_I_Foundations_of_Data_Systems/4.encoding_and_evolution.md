# 数据编码与演化

应用程序不可避免地需要随着时间而变化。大多数情况下，更改应用程序功能时，也需要更改其存储的数据：可能需要增加字段，或者改变已有的字段。

当数据格式或者 schema 改变时，代码也需要相应的更改。然而这并非易事：
* 对于服务端应用，可能需要执行滚动升级。
* 对于客户端应用，不能期望用户很快执行升级。

这意味着新旧版本的代码，以及新旧数据格式，可能会在系统内共存。为了使系统顺利运行，需要保持双向的兼容性：
* 向后兼容：新代码可以读取旧数据
* 向前兼容：旧代码可以读取新数据

向后兼容通常不难实现，实在不行只需保留旧的代码处理旧数据。向前兼容比较棘手，它需要旧代码忽略新版本的代码所做的添加。

本章将介绍多种编码格式，这里需要关注的问题是它们如何处理模式变化，以及如何支持新旧数据和新旧代码共存的系统。之后，还将讨论这些格式如何用于数据存储和通信场景。

## 数据编码格式
程序使用两种不同的数据表示形式：内存中的数据结构和通过网络发送的字节序列。两种格式的转化分别称为编码和解码。
### 语言特定的格式
编程语言内置的格式虽然使用起来方便，但是有如下缺点：
* 通常与特定编程语言绑定，用其它语言访问时非常困难。
* 安全问题。为了恢复任意类的数据，解码过程需要能够实例化任意的类。可能被用来执行任意代码。
* 在这些库中，多版本兼容性问题通常不被考虑。
* 效率低，包括编码解码时间和编码结构的大小。

由于以上原因，使用语言内置的编码不是个好主意，除非只是为了临时尝试。
### JSON，XML 和二进制变种
目标转向可由不同编程语言使用的标准化编码。显然 JSON 和 XML 是其中的佼佼者。

JSON、XML 和 CSV 都是文本格式，因此具有不错的可读性。但是它们也有一些微妙的问题：
* 数字编码模糊
* 不支持二进制字节序列
* JSON 和 XML 虽然支持 schema，但是难以学习和使用。CSV 没有任何 schema 支持。

尽管它们有着各种各样的问题，但总体来说很受欢迎。因为它们使得不同组织就格式达成一致。

在 JSON 和 XML 之上有一些二进制编码上的改进，使得格式更加紧凑。然而，由于它们没有规定模式，所以需要在编码数据时包含所有的对象字段名称。所以它们的紧凑性十分有限。
### Thrift 和 Protocol Buffer
Thrift 和 protobuf 是基于相同原理的两种二进制编码库。它们都需要 schema 来编码任意的数据。

protobuf 的示例如下：
``` protobuf
message Person {
  required string user_name
  = 1;
  optional int64 favorite_number = 2;
  repeated string interests
  = 3;
}
```
它们各有各自的代码生成工具，可以根据模式定义生成多种编程语言的类。由于是代码生成而不是反射，所以避免了前面所说的实例化任意类的安全问题。

Thrift 有两种不同的二进制编码格式，分别是 BinaryProtocol 和 CompactProtocol。

在 BinaryProtocol 中，每一个字段的编码有几个部分：类型、tag、长度（可选）、实际内容。与 JSON 等格式的最大区别是，编码后的数据中没有字段名。而是使用数字 tag，这些数字是模式定义中出现的数字。从而格式更加紧凑。

在 CompactProtocol 中，空间被进一步压缩。字段类型和字段标签被打包到一个字节中。整数使用可边长度整数实现：每字节的最高位用来指示是否还有更多的字节，越大的数字所需要的字节数越多。

protobuf 与 CompactProtocol 的格式非常相似。需要注意的一个细节是，`optional` 和 `required` 对字段如何编码没有任何影响。影响是在解码时，如果标记为 `required` 的字段没有值，则运行时检查会出现失败。

Thrift 和 protobuf 如何应对模式演化呢？
#### 字段名称和字段标签演化
字段名称可以随意更改，因为它们不会出现在编码结果中。而字段标签不可以随便更改，它会导致之前编码的数据无效。
#### 增加字段或删除字段
可以增加新的字段，只需要使用不同的 tag。
* 向前兼容：旧代码读取新数据时，会忽略新的字段。
* 向后兼容：新的代码总是可以读取旧的数据。唯一的细节是，不能添加 `required` 字段，因为旧数据里没有对应的值。因此，只能添加可选的或者具有默认值的字段。

删除字段类似添加字段，不过向前和向后兼容性问题相反。
* 向前兼容：只能删除可选的字段
* 向后兼容：需要使用不同的 tag
#### 数据类型演化
可以改变字段的类型吗？这是有可能的，但是有丢失精度或者阶段的风险。例如在不同长度的整数之间转换。

protobuf 中的一个奇怪的细节是，它没有列表或数组类型，而是有字段的重复标记 (`repeated`)。可以将可选单值字段更改为重复字段。读取旧数据的新代码会看到包含零个或者一个元素的列表，读取新数据的旧代码则只能看到列表的最后一个元素。

Thrift 有单独的列表类型，不支持从单值到多值的改变。但是它具有支持嵌套列表的优点。
### Avro
### 模式 (schema) 的优点

## 数据流动的模式 (mode)
### 基于数据库的数据流动
### 基于服务的数据流动：REST 和 RPC
### 基于消息传递的数据流动