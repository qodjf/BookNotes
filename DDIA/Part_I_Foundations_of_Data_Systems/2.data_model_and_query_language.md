# 数据模型与查询语言
“语言的边界就是世界的边界。”数据模型不仅对软件的编写方式，而且还对如何思考待解决的问题都有深远的影响。

大多数应用程序是通过一层一层叠加数据模型来构建的。对于每一层，关键问题是：该层如何用更低的一层来表示。例如：
| 不同层级 |
| - |
| 现实世界 |
| 数据结构和操作数据结构的 API |
| 通用数据模型（例如 JSON 或者 XML） |
| 在内存或者磁盘中的字节 |
| 电流、光脉冲、磁场 |

1. 现实世界如何用领域对象和操作来表示。
2. 存储这些数据结构时，采用通用数据模型（例如 JSON 或者 XML）来表示。
3. 数据库工程师决定用何种内存、磁盘表示这些数据。同时支持查询、搜索、操作和处理。
4. 硬件工程师则需要考虑如何用电流、磁场来表示字节。

每一层都通过提供一个简洁的数据模型来隐藏下层的复杂性。

本章讲述一系列用于数据存储和查询的通用数据模型（第 2 点）。第 3 章讨论存储引擎，即第 3 点。

## 关系模型与文档模型
### 关系模型
数据被组织成关系，其中每个关系 (表) 都是 tuple (行) 的无序集合。

关系数据库起源于商业数据处理。从今天的角度来看，用例很常见，主要是事务处理（如航空公司订票）和批处理（如产生工资单报告）。

当时的其它数据库迫使应用开发人员考虑数据的内部表示。关系模型的目标就是*将实现细节隐藏在更简洁的接口后面*。
### NoSQL 的诞生
NoSQL 这个名字是不恰当的，它并不指代具体的某些技术。采用 NoSQL 数据库有这样几个驱动因素：
* 比关系数据库更好的扩展性需求
* 免费和开源而非商业数据库
* 关系模型不能很好地支持一些特定的查询操作（？）
* 对关系模型的一些限制感到沮丧，渴望更动态和更具表达力的数据模型。

不同的应用程序有不同的需求。在可以预见的将来，关系数据库仍将继续与各种非关系型数据库存储一起使用。

### 对象-关系不匹配
大部分应用采用面向对象编程语言。如果数据存储在关系表中，那么应用层代码中的对象与数据库模型中的表行列之间需要一个笨拙的转换层。称之为对象关系不匹配。

#### 一对多的关系
大多数人在他们的职业中有多份工作。用户与这些项目之间存在一对多的关系，可以用多种方式表示：
* 在传统的 SQL 模型中，最常见的规范化表示是把工作放在工作表中，并使用外键引用 users 表。
* 之后的 SQL 标准增加了对结构化数据类型和 XML 数据的支持。这允许将多值数据存储在单行内，并支持查询和索引。
* 第三种是编码成 JSON 或 XML，然后存放到 text 列中，并由应用程序解释其内容。对于此方法，通常不能使用数据库的查询和索引功能。

对于简历这种自包含文档，使用 JSON 表示非常合适。面向文档的数据库都支持该数据模型。JSON 比多表模式具有更好的局部性，所有相关信息都存放在一个地方，不需要做 join。

一对多关系，意味着数据存在树结构，JSON 表示将该树结构显式化。

### 多对一和多对多关系
多个人住在同一个地方，则是一种多对一的关系。比如多个人住在同一个地方。在规范化表示中，应该使用 ID 表示地区，然后 ID 到实际地址的对应存放在另一张表中。使用 ID 的好处是，它对人类没有任何直接意义，所以永远不需要直接改变。

而这种数据规范化需要表达多对一的关系，不适合文档模型。而对于关系数据库，由于支持 join 操作，可以很方便地通过 ID 来引用其它表中的行。而文档数据库中，通常不支持 join，即便支持也比较弱。

即使数据一开始没有联结，适合使用文档模型，但随着应用支持越来越多的功能，数据也变得更加互联一体化。

关系数据库也支持多对多关系，只需要结合多对一和一对多。相当于有一个 users 表，一个地址表，一个 users 和地址的多对多的关系的表。

### 文档模型是否则重演历史？
虽然关系数据库中经常使用多对多关系和联结，但文档数据库和 NoSQL 再次引发了**如何最佳表示数据关系**的争论。

关系模型中，可以很方便地添加索引。关系模型的一个核心要点是：只需要构建一次查询优化器，使用该数据库的应用程序都可以从中受益。

在表示多对一和多对多的关系时，关系数据库和文档数据库并没有根本的不同：相关项都由唯一的标识符引用。该标识符在关系模型中被称为外键，在文档模型中被称为文档引用。

### 关系数据库与文档数据库的现状
#### 应用程序代码的简单
一对多关系，使用文档模型更合适。多对多关系，更适合使用关系模型。而对于高度关联的数据，文档模型不太适合，关系模型可以胜任，而图模型则是最为自然的。
#### 模式的灵活性
文档数据库并不是无模式。更准确的术语应该是读时模式，数据的结构是隐式的，读取时才做解释。与关系数据库中的写时模式对应。读时模式类似于动态（运行时）类型检查，写时模式类似于静态（编译时）类型检查。

在“静态类型”数据库模式中，模式的更改很不方便，每一行都需要重写，速度慢且可能需要停机。

如果集合中的项由于某种原因不具有相同的结构，则模式带来的损害大于它能提供的帮助，无模式文档可能是更适合的数据模型。但是，当所有记录结构都相同时，模式则是记录和确保这种结构的有效机制。
#### 查询的数据局部性
文档通常存储为连续字节，更具有局部性。而关系模型中，数据被划分在多个表中，需要 join，所以更不具有局部性。

局部性优势仅使用需要同时访问文档大部分内容的场景。如果只访问一小部分，则对于大型文档来说就有些浪费。

对文档更新时，通常会重写整个文档。而只有修改量不改变原文档大小时，才能原地覆盖更新。因此，通常建议文档应该尽量小，且避免写入时增加文档大小。
#### 文档数据库与关系数据库的融合
自 2000 年中期以来，很多关系数据库都支持 JSON 和 XML。因此应用程序可以获得与文档数据库非常相似的数据模型。

而文档数据库方面，RethinkDB 的查询接口支持和关系数据库类似的联结。

随着时间推移，似乎关系数据库和文档数据库变得越来越相近，或许这是一件好事：数据模型可以互相补充。
## 数据查询语言
SQL 是一种声明式查询语言。

声明式查询语言很有吸引力，比命令式 API 更简洁和容易使用。但*更重要的是*，它隐藏了数据库引擎的内部实现细节，使得数据库系统可以在不改变查询语言的情况下提升性能。SQL 不保证查询结果的顺序。最后，声明式语言通常适合于并行执行。这三个特征都使得声明式查询语言的性能可以更高。
### Web 上的声明式查询
对于 Web 浏览器的例子，使用声明式 CSS 样式表比用 JavaScript 命令式地操作样式要好得多。类似地，在数据库中，像 SQL 这样的声明式语言比命令式查询 API 要好得多。
### MapReduce 查询
MapReduce 既不是声明式查询语言，也不是一个完全命令式的查询 API，而是介于两者之间：查询的逻辑用代码片段表示，这些代码片段可以被处理框架重复调用。代码是命令式的，而框架是声明式的。基于函数式编程中的 `map` 和 `reduce` 操作。

map 和 reduce 函数必须是纯函数，不能有任何副作用。MapReduce 是一个相当底层的编程模型，用于在计算集群上分布执行。SQL 是更高层次的查询语言，可以借助 MapReduce 来分布式地执行。

MapReduce 的一个易用性问题是，必须编写两个紧密配合的函数，这比编写单个查询更难。此外，声明式查询语言为查询优化器预留了更多优化的空间。

MongoDB 支持称为聚合管道 (aggregate pipeline) 的声明式查询语言。聚合管道在表达能力上是 SQL 的子集。这个故事的寓意是：NoSQL 系统可能会发现自己意外地重新发明了 SQL，尽管是伪装的。
## 图状数据模型
多对多关系是不同数据模型之间的重要区别特征。如果只有一对多关系或者记录之间没有关系，那么文档模型是最合适的。

但是，如果多对多关系很常见呢？关系模型能够处理简单的情形。随着数据之间的关联越来越复杂，将数据建模为图模型是自然的选择。

图由两种对象组成：顶点（实体）和边（关系）。顶点和边可以具有属性。图的顶点并不局限于表示相同类型的事物。图更为强大的用途在于，提供了单个数据存储中保存完全不同类型的对象的统一的方式。

本节讨两种存储模型：属性图模型 (property graph)、三元存储模型 (triple store)。三种声明式图查询语言：Cypher, SPARQL, Datalog。

### 属性图模型
可以将图存储看作由两个关系表组成，一个是顶点，一个是边。通过顶点可以找到它有哪些出边和入边，以及它自己的属性。通过边可以找到它连接的两个顶点，以及它自己的其它属性。

通过对不同类型的关系使用不同的标签，可以在单个图中存储多种不同类型的信息，同时仍然保持整洁的数据模型。

这些特性为数据建模提供了很大的灵活性。图有利于演化，可以方便地扩展和添加关系。
### Cypher 查询语言
Cypher 是一种用于属性图的声明式查询语言。其语法比较简洁和直观。如下是查询从美国移民到欧洲的人员名单。
```Cypher
MATCH
  (person) -[:BORN_IN]-> () -[:WITHIN*0..]-> (us:Location {name:'United States'}),
  (person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (eu:Location {name:'Europe'})
RETURN person.name
```
### SQL 上的图查询
可以用关系数据库表示图数据，即一个顶点表，一个边的表。把图数据放在关系结构中，是否意味着可以用 SQL 查询呢？

答案是肯定的，但是存在困难。在关系数据库中，通常预先知道查询中需要哪些 join 操作。而对于图查询，在找到要查找的顶点前，可能需要遍历未知数量的边，也就是说，**join 操作的数量不是预先确定的**。

SQL 后来支持了 `WITH RECURSIVE` 语法。但与 Cypher 相比，仍显得非常笨拙。

对于相同的查询，一种语言需要 4 行，另一种语言需要 29 行。这足以说明不同的数据模型适用于不同的场景。因此，选择适合应用程序的数据模型非常重要。

### 三元存储
三元存储几乎等同于属性图模型。在三元存储中，所有信息都以非常简单的三元结构存储，即主体、谓语、客体。

三元存储中的主体相当于图中的顶点。而客体则有两种情况。客体是原始数据类型的值时，则表示是主体的属性；客体是另一个顶点时，则谓语表示边。

可以看到边和属性的表示没有什么差别。可以同时对两者执行谓语操作，所以可以采用相同的语法来匹配属性上的查询条件。
```SPARQL
SELECT ?personName WHERE {
  ?person :name ?personName.
  ?person :bornIn / :within* / :name "United States".
  ?person :livesIn / :within* / :name "Europe".
}
```
可以看到语法同样比较简洁。
#### Datalog
Datalog 的数据模型类似于三元存储模式，但更为通用一些。它采用“谓语（主体，客体）”的表达方式。

Datalog 是 Prolog 的子集。通过已有的谓语定义新谓语的规则，逐渐构建出更复杂的规则即谓语。这样，复杂的查询可以通过每次完成一小块而逐步构建。

Datalog 需要采取与其它查询语言略有不同的思维方式，但它非常强大，因为规则可以组合和重用，类似函数式编程。

## 小结
文档数据库和图数据库有一个共同点，那就是它们通常不会对存储的数据强加某个模式，这可以使应用程序更容易适应不断变化的需求。

数据模型和查询语言是紧密关联的。