# 事务
事务的作用：
* 原子性：使得应用层的错误处理简单。失败了可以安全地重试。
* 隔离性：保证了并发操作时，不会出现奇怪的问题。
* 持久性：基本要求
* 一致性：应用层保证，本质上不属于数据库。
## 理解事务
### ACID
即事务所提供的安全性保证。
#### 原子性
在多线程编程中，原子性指其它线程无法看到另一个线程执行的原子操作的中间结果。

而 ACID 中，原子性指事务要么执行完成，要么失败而不产生任何影响。至于多个线程访问相同的数据会发生什么，由 ACID 中的隔离性定义。更准确的称呼应该是中止性。

#### 一致性
ACID 中的一致性，指对数据有特定的预期状态。任何数据更改必须满足这些状态约束。本质上需要应用层定义事务来维护状态的一致性。一致性本身并不源于数据库，字母 C 并不应该属于 ACID。

#### 隔离性
多个客户端访问相同记录时，可能会遇到并发问题。隔离性是指数据库保证事务提交时，结果与各个事务串行执行时完全相同。叫做可串行化隔离。多个事务不会互相干扰。实际上出于性能的考虑，有更弱的隔离级别。

#### 持久性
保证事务一旦提交成功，即使存在硬件故障或数据库崩溃，事务所写入的数据也不会丢失。

对于支持远程复制的数据库，意味着数据已复制到多个节点。不存在完美的持久性。

### 单对象与多对象操作
ACID 中的原子性和隔离性针对的主要是包含多个写操作的事务。

原子性和隔离性也适用于单个对象的更新。例如不能出现部分更新的对象。例如原子自增。虽然这些操作可以防止并发修改同一对象时的更新丢失问题。但这些东西并不属于通常意义上的事务。通常意义上的事务针对的是多个对象。
#### 多对象事务的必要性
多对象事务的缺点：
* 跨分区时，难以正确实现
* 在高可用或极致性能场景下有很多负面影响

必要性：
* 对于关系数据模型，表中的某行可能是另一个表中的外键。多对象事务确保这些外键引用的有效性，即多个相互引用的外键需要同时更新。
* 对于文档数据模型，缺少 join 支持，往往滋生反规范化。所以需要更新多个文档，需要事务做同步。
* 二级索引需要同步更新。从事务角度看，二级索引是不同的数据库对象。
#### 错误处理与中止
中止流程的重点是支持安全地重试，而不是简单退出。

重试中止的事务虽然是一个简单有效的错误处理机制，但并不完美：
|   问题      | 方案   |
| ------   | -----  |
| 事务可能实际上已经执行成功，只是网络中断让客户端看起来失败。此时重试会导致重复执行。 | 需要应用层删除重复数据。 |
| 如果错误是因为系统超负荷，重试会使情况更糟糕。 | 设置重试次数上限 |
| 如果出现了永久性故障（例如违反约束），则重试毫无意义 | 不要重试 |
| 如果已经产生数据库之外的副作用，则就算事务中止，副作用也已生效 | 可以考虑两阶段提交 |
| 客户端在重试的过程中也失败了，则没有其它应用负责重试了 | 无法解决 |

## 弱隔离级别
两个事务操作不同数据，或者都只做读取，则不存在竞争关系。当两个事务处理相同数据，一个读一个写，或者两个都写时，就会引发并发问题。

并发控制很难。隔离是假装没有并发，让应用程序员的生活更轻松。但是实现隔离没有想象的那么简单，可串行化的隔离会严重影响性能。**隔离级别是在性能与应用安全之间做平衡**。

### read committed
读提交是最基本的事务隔离级别。保证：
1. 读取时，只会看到已成功提交的修改（防止脏读）
2. 写入时，只会覆盖已成功提交的数据（防止脏写）

脏读会引发的问题：
1. 看到部分更新
2. 已经看到的更新可能会被回滚，导致奇怪的结果

#### 实现读提交
防止脏写：采用行级锁。想修改时先获取锁，事务提交后才会释放锁。

防止脏读：一种方式是使用相同的锁。但这会带来性能问题。大多数数据库会维护旧值和当前持锁事务将要设置的新值这两个版本。提交前，其它读操作会读到旧值，提交后会读到新值。

### 快照隔离和可重复读
不可重复读：在事务中读取两次，第一次读取到了另一个事务提交前的内容，第二次读取到了另一个事务提交后的内容。把两次的结果结合起来，从而观察到数据库处于不一致的状态。

无法容忍不一致的场景：备份场景，分析查询与完整性场景。

快照隔离：每个事务都从事务开始前的一致性快照中读取。对于长时间运行的只读查询（如备份和分析）非常有用。查询结果的含义非常明确。

#### 实现快照隔离
与读提交类似，快照隔离使用写锁来防止脏写。但是读取不需要加锁。从性能角度看，快照隔离的一个关键点就是读写互不干扰。

实现方式：比防止脏读更通用的机制。数据库保留了对象多个不同的提交副本，不同的事务可以看到不同的提交副本，称为多版本并发控制。

支持快照隔离的存储引擎往往直接采用 MVCC 来实现读提交隔离。典型做法是，在读提交下，对每一个查询创建一个快照，而在快照隔离下，对每一个事务创建一个快照。

事务开始时，赋予其一个唯一的单调递增的事务 ID。事务写入时，所写的数据会带有标记写入者的事务 ID。表中的每一行都有 `created_by` 字段和 `deleted_by` 字段。如果要删除某行，就只会标记删除。而一个更新操作会被转换为一个删除操作和一个创建操作，也就是说数据库的内容只会增加。只有垃圾回收会释放存储空间。

#### 一致性快照的可见性规则
当且仅当以下两个条件都成立，则该数据对事务可见：
* 事务开始时，创建该修改的事务已经完成了提交。
* 对象没有被标记为删除，或者即使被标记为删除，删除事务在当前事务开始时还没有完成提交。

#### 索引与快照级别隔离
一种办法是索引直接指向对象的所有版本，然后想办法过滤对当前事务不可见的那些版本。另一种方式是使用函数式可持久化数据结构的思想，每次修改索引时创建一棵新的 B 树。从而所有的版本都得以保留。采用这种办法依然需要后来进行压缩和垃圾回收。

### 防止更新丢失
读提交和快照隔离级别，主要都是为了解决只读事务遇到并发写时应该看到什么。而没有触及到另一种，即两个写事务并发。

除了脏写，写并发还会带来其它值得关注的冲突问题，最著名的就是**更新丢失问题**。更新丢失，即是两个事务同时做读-修改-写的时候，第二个写操作导致第一个写操作的更新丢失。有多种可行的解决方案。
|    方案   | 描述  | 优点 | 缺点 |
| -------- | ----  | -----  | ---- |
| 原子更新 | 数据库提供了某些原子更新操作 | 如果可行，是推荐的最佳方式 | 应用范围小 |
| 显式加锁 | 应用程序显式锁定待更新的对象 | 可行 | 应用层逻辑复杂，容易出错 |
| 自动检测更新丢失 | 先让事务并发执行，如果事务管理器检测到了更新丢失的风险，则中止当前事务并重试。 | 数据库掌管，不容易出错。数据库完全可以借助快照隔离级别来高效地执行检查。 | 无 |
| 原子比较和设置 | 当上次读取的数据没有发生变化时才更新 | 数据库支持 | 数据库需要保证这样一个操作本身是原子操作。应用前需要仔细检查其安全运行条件。 |

#### 冲突解决与复制
加锁和原子修改都有个前提，即只有一个最新的数据副本。然而对于多主节点或无主节点的多副本数据库，会出现多个最新的数据副本。加锁和原子修改不再适用。

如果操作可以交换，则原子操作在多副本下也可以工作。例如计数器递增。而“最后写入获胜”则容易丢失更新。详见第五章冲突解决。

### 写倾斜和幻读 (phantoms)
更为微妙的写冲突的问题是**写倾斜**。

例子: 两个事务先做查询，然后根据查询结果决定下一步的行为。如果事务决定继续执行，则会发起数据库写入。而这个写操作会改变步骤 2 做出决定的前提条件。换句话说，在串行执行时，不可能两个事务都执行成功。

可以将写倾斜视为一种更广义的更新丢失问题。如果两个事务读取相同的一组对象，然后更新其一部分：不同的事务可能更新不同的对象，则可能发生写倾斜；更新相同的对象，则可能发生脏写或者更新丢失（覆盖别人未提交的就是脏写，覆盖别人已提交的就是更新丢失）。

目前所有的数据库实现，其快照级别隔离都不支持检测写倾斜问题。自动防止写倾斜要求真正的可串行化隔离。

一个事务中的写入改变了另一个事务查询结果的现象，称为**幻读**。如果事务是只读查询，则快照隔离可以解决。如果事务还有写操作，那就是发生了写倾斜，需要真正的可串行化隔离。

从读操作来看，写倾斜属于幻读。从写操作来看，写倾斜属于更新丢失。

## 可串行化
弱隔离级别的问题：
* 难以理解，而且不同数据库的实现不尽一致。
* 如果检查应用层的代码，难以判断它在特定隔离级别下是否安全
* 缺乏工具来检测竞争状况

可串行化隔离通常被认为是最强的隔离级别。可以防止所有可能的竞争条件。但是它为什么没有被广泛使用呢？我们需要看看各种可能实现的优点和缺点，以及其适用场景。

### 实际串行执行
实际串行执行，即只使用一个线程来按顺序执行事务。

满足以下条件时，适合使用实际串行执行：
* 事务必须简短而高效。最好采用存储过程的方式，去掉人为交互和 IO 开销。
* 活动数据集可以加载到内存
* 写入吞吐量足够低，以使得单个 CPU 可以处理。
* 跨分区事务虽然可以支持，但是占比必须很小。

### 两阶段加锁
在两阶段加锁中，不止并发写之间会互斥，读和写之间也会互斥。而快照级别隔离中，读写互不干扰。另一方面，两阶段加锁可以防止所有的竞争条件。

#### 实现
读取对象需要先获取共享锁，修改对象要先获取独占锁。获取锁之后，会一直持有到事务结束。这也是两阶段名称的由来，在第一阶段即事务执行时获取锁，第二阶段即事务结束时释放锁。

很容易出现死锁。数据库系统会自动检测死锁并强行中止其中的一个来打破僵局。而被中止的事务需要应用层重试。

#### 性能
性能是其主要缺点。其事务吞吐量和查询响应时间相比与其它弱隔离级别下降非常多。部分原因在于锁的开销，但**更重要的是其降低了事务的并发性**。任何可能导致竞争的事情，都要按顺序完成。

当一个事务需要等待另一个事务时，最终的等待时间几乎是没有上限的。因此，在两阶段加锁模式下，数据库的访问延迟具有非常大的不确定性。

与基于加锁方式实现的读提交隔离相比，两阶段提交下，死锁可能会变得更为频繁。频繁死锁导致频繁中止和重试，性能和效率必然大打折扣。

#### 谓词锁
谓词锁的作用类似于共享/独占锁，区别在于，它不属于某个特定的对象，而是作用于满足某些搜索条件的所有查询对象。

关键点在于，谓词锁甚至可以保护数据库中那些尚不存在但可能马上会被插入的对象（以防止幻读）。将两阶段加锁与谓词锁结合使用，数据库可以防止所有形式的竞争条件。

#### 索引区间锁
不幸的是，谓词锁性能不佳。实际上使用的是索引区间锁，本质上是对谓词锁的简化和近似。简化的方式是将其保护的对象扩大化。其开销低得多，是一种很好的折衷方案。

### 可串行化快照隔离 (Serializable Snapshot Isolation)
不禁要问，串行化隔离与性能是从根本上互相冲突而无法兼得吗？或许并非如此。可以看看可串行化快照隔离算法。

#### 悲观与乐观的并发控制
两阶段加锁是一种典型的**悲观并发控制**，可能冲突则必须等待。某种意义上讲，串行执行是一种极端悲观的选择。

相比之下，可串行化快照隔离是一种乐观并发控制。只有当事务提交时，数据库会检查是否确实发生了冲突，从而决定是否中止。

乐观并发控制的缺点：如果冲突很多，则性能不佳，大量事务需要中止。如果系统已接近最大吞吐量，反复重试反而会使得性能更差。优点：更多的并行性。

实现：SSI 基于快照隔离，所有读取操作都从一致性快照中读取。在此基础上，SSI 增加了相关算法来检测写入之间的串行化冲突从而决定中止哪些事务。

#### 基于过期的条件做决定
在之前写倾斜的例子中，两个事务是基于某些前提条件而决定采取行动。而在事务提交时，前提条件不再满足。

数据库应该防止事务基于过期的条件做决定。安全起见，它假定对查询结果（决策的前提条件）的任何变化都应使写事务失效（只读事务不必失效）。数据库必须检测事务是否会修改其它事务的查询结果。如何检测呢？分为以下两种情况：
* 读取了一个即将过期的 MVCC 对象（也即，读取之前已经有未提交的写入）
* 写入了一个即将完成的读取（也即，写入之前已经有未提交的读取）

#### 检测是否读取了过期的 MVCC 对象
数据库需要跟踪那些由于 MVCC 可见性规则而被忽略的操作。当事务提交时，如果有不可见的写操作已完成提交，则中止当前事务。

为什么要等到提交时才决定是否中止？为何不在发现读取旧值时直接中止？原因有二：
* 只读事务不需要中止
* 被忽略的写操作所在的事务可能中止或还处于未提交状态，因此读取的并非是过期值。

通过减少不必要的中止，SSI 可以高效支持那些需要在一致性快照中运行很长时间的读事务。

#### 检测写是否影响了之前的读
SSI 使用了与索引区间锁类似的技术，只有一点差异：SSI 不会阻塞其它事务。

当一个事务尝试修改时，首先检查索引，从而确定是否最近存在一些读目标数据的其它事务。在其它事务提交时，才会通知它所读到的数据现在已经发生了变化。

#### 性能
需要权衡考虑跟踪事务读写的粒度。粒度小时并发控制更好，但是开销也更大。

与两阶段加锁相比，读写通常不会互相拥塞。这样的设计使得查询延迟更加稳定。特别的是，执行只读查询不需要任何锁，这对于读密集的负载非常有吸引力。

与实际串行相比，SSI 可以突破单个 CPU 核的限制。还可以支持多分区事务并保证可串行化隔离。

事务中止的比例会显著影响 SSI 的性能表现。所以 SSI 要求读-写型事务要简短，只读查询没有限制。总体来讲，SSI 更能容忍执行缓慢的事务。

## 总结
|         | 脏读   |  脏写  | 不可重复读 | 写倾斜 | 幻读 |
| -------- | -----  | ---- | ----  | ----  | ----  |
| 读未提交 read uncommitted | × | × | × | × | × |
| 读已提交 read committed | √ | √ | × | × | × |
| 快照隔离 repeatable read | √ | √ | √ | × | × |
| 可串行化 serializable | √ | √ | √ | √ | √ |
