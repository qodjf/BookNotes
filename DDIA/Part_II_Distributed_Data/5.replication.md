# 数据复制
复制的作用：
* 高可用性：容忍节点出现故障
* 网络连接断开与容错
* 低延迟：可以将数据放在距离用户更近的地方
* 可扩展性：提高了读操作的可吞吐量

挑战：复制持续更改的数据

## 单主节点复制
如何确保所有的副本都是一致的？

工作原理：
1. 指定某一个节点为主节点。只有主节点可以处理写请求。主节点将数据写入本地存储
2. 主节点把数据更改发送给所有从节点。所有从节点应用数据更改
3. 客户端在主节点或者从节点上读

### 同步复制与异步复制
| | 同步 | 异步 |
| - | - | - |
| 优点 | 从节点和主节点总是保持一致,不会丢数据 |  不管发生什么，可以持续响应写请求，吞吐量高。|
| 缺点 | 失败的从节点会阻塞后续所有写操作 | 确认了的写操作也有可能丢，无法保证数据的持久化。 |

半同步：一个从节点同步，其它从节点异步

### 添加新的从节点
可以在不停机、服务不中断的情况下完成从节点的添加。步骤如下：
1. 对主节点产生一个一致性快照
2. 拷贝快照到从节点上并应用
3. 请求快照之后的所有变更日志
4. 应用变更日志 (catch up)

可以自动化

### 处理节点失效
目标：尽管个别节点失效，保持系统总体的连续运行，并尽可能减小节点中断的影响
#### 从节点失效：追赶
节点恢复后请求落下的数据变更
#### 主节点失效：切换
步骤如下：
1. 确认主节点失效：超时机制。没有万无一失的方法能够知道问题在哪里
2. 选举新的主节点。共识问题（第 9 章）
3. 重新配置系统使得主节点生效。客户端也要重新配置。原来的主节点需要降级为从节点。

变数：
1. 从节点数据不完整。主节点失效后又重新上线，如何处理冲突的写请求？常见的方案是丢弃主节点上未完成复制的数据。
2. 如果数据库之外的其它系统依赖于数据库的内容并一起协同使用，则数据丢弃的方案特别危险。会造成意料之外的 bug
3. 两个主节点。脑裂，非常危险，会发生冲突。需要 fencing
4. 如何设置合适的超时来检测主节点失效？太长了导致恢复慢，太短了导致不必要的切换。

### 复制日志的实现
#### 基于语句的复制
把操作语句直接发给从节点。

pros: 简单

cons:
* 非确定的函数在不同机器上会产生不同的结果
* 依赖于现有数据的操作，要求所有副本按照相同的顺序来执行语句。限制了系统的并发事务。
* 有副作用的语句在多个副本上可能会产生不同的副作用

#### 预写日志传输
每个写操作都会以追加的形式写到日志里面。直接把日志的追加转发给从节点。

cons:
* WAL 的日志描述过于底层，使得复制方案与存储引擎紧密耦合。使得主从节点必须运行版本相同的软件，从而导致升级时必须停机。

#### 基于行的逻辑日志的复制
复制和存储引擎采用不同的日志格式，被称为逻辑日志。关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求。

pros:
* 与存储引擎解耦，更容易向后兼容，从而可以不停机升级。甚至运行不同的存储引擎，从节点可以自己决定如何应用变更日志。
* 对于外部应用程序来说，逻辑日志更容易解析。(change data capture)

#### 基于触发器的复制
在某些情况下，我们需要更高的灵活性。例如：只复制一部分数据，从一种数据库复制到另一种数据库，定制冲突解决逻辑。

pros: 灵活性

cons:
* 开销更高
* 更容易出错
* 有更多限制

## 复制滞后问题
除了容忍节点故障，复制还带来了可扩展性和低延迟。

对于读操作密集的负载，很适合使用主从复制。添加更多从副本，就可以提高读请求的吞吐量。但是，这种方法实际上只能使用异步复制。

不幸的是，在异步的情况下，会出现从节点落后于主节点的情况，应用会读到过期的信息。在停止写入后，从节点最终会赶上主节点并保持一致，称为最终一致性。

本节介绍三种复制滞后可能出现的问题，并给出相应的解决思路。

### 读自己的写
问题：往主节点写，从从节点读，可能会无法读取到刚刚写入的数据。看起来像是数据丢失了。

**写后读一致性**：也称为读写一致性。保证用户可以看到自己的写入。

解决方案：保证用户从包含更新的节点读取
* 可能会被修改的内容，从主节点读取，否则在从节点读取
* 通过其它方案判断是否从主节点读取。例如跟踪从节点的复制滞后程度
* 客户端请求时带上最近一次写请求的时间戳，从而由包含该时间戳的节点提供服务。但是此时时间戳的同步是一个关键问题。

### 单调读 (Monotonic Reads)
问题：读取两次，出现了数据回滚的现象。原因是先从一个少量滞后的从节点读取，再从一个大量滞后的从节点读取。

单调读一致性：保证不会出现数据回滚的现象。比强一致性弱，但是比最终一致性强。

解决方案：每个用户总是从固定的同一个副本读取。例如，基于用户 ID 哈希选取副本。

### 前缀一致读
前缀一致读保证：对于一系列按照某个顺序发生的写请求，读取时总会按照写入的顺序读取到。

这是一个在分区数据库会出现的特殊问题。如果只有一个分区，则总是以相同顺序写入，不会发生这种问题。在分区的情况下，不同的分区独立运行。则对于写入了不同分区的两个写请求，在不同的副本的写入顺序可能不一样，导致读取的时候可能先读取到后发生的写入。

解决方案：确保任何具有因果关系的写入都由同一个分区处理。有一些新的算法，显式追踪事件因果关系，即追踪 happens-before 关系。

### 复制滞后的解决方案
使用最终一致性系统时，最好事先就思考这样的问题：如果复制延迟增加到几分钟甚至几小时，应用层的行为是什么样子？如果不可接受，就要提供比最终一致性更强的保证，例如写后读一致性。

某些情况下在应用层可以提供比底层数据库更强有力的保证。代价则是，应用层代码会变得复杂且容易出错。这也是事务存在的原因，事务使应用层代码可以更简单，事务是数据库提供更强保证的一种方式。

在分布式数据库中，很多系统放弃了支持事务，并断言在分布式系统中，最终一致性是无可避免的选择。这种观点虽然有一定道理，但是情况并不是这么简单。后面的章节会形成一个更为深入的观点。我们会理解事务，并寻找其它替代机制。

## 多主节点复制
除了主从复制，还存在其它有趣的方案。首先，主从复制有一个明显的缺点：系统只有一个主节点，而所有写入都必须经由主节点。如果主节点无法连接，则会影响所有的写操作。

对主从模型进行自然的扩展，则可以配置多个主节点，多个主节点都可以处理写入操作。此时，每个主节点还扮演其它主节点的从节点。
### 适用场景
在一个数据中心内部使用多主节点基本没有意义，其复杂性已经超过收益。但是，在以下场景是有意义的。
#### 多数据中心
为了容忍整个数据中心级别故障或者更接近用户，可以把数据库的副本横跨多个数据中心。然而这样只可以使得读操作靠近用户，为了使写操作也靠近用户，需要使得每个副本都可以处理写操作。在数据中心内部使用主从复制，在数据中心之间，由各个数据中心的主节点来负责同步其它数据中心的主节点。

pros:
* 性能。写操作靠近用户
* 容忍数据中心失效。
* 容忍网络问题。多主节点模型常采用异步复制。

cons: 不同数据中心可能会修改相同的数据，因而必须解决潜在的写冲突。
#### 离线客户端操作
另一种多主复制比较适合的场景是：应用在与网络断开后还需要继续工作。

例如手机里的日历程序。它需要在网络断开时继续工作，在网络连上后同步到互联网。这种情况下，每个设备都有一个充当主节点（处理离线状态下的写操作）的本地数据库。从架构层面看，这基本等同于数据中心之间的多主复制。
#### 协作编辑
实时协作编辑应用程序允许多个用户同时编辑文档。我们通常不会将其等价于数据库复制问题，但二者确实有很多相似之处。当一个用户编辑时，更改会立即应用到本地，然后异步复制到服务器和其它用户。如果允许多主复制，则可以降低用户的延迟，大大提升用户体验。

### 处理写冲突
多主复制的最大问题是可能发生写冲突，这意味着必须有方案来解决冲突。

例如，一个主节点把标题从 A 改成 B，另一个主节点把标题从 A 改成 C。每个写请求都成功返回，然而将修改同步给对方时，就会发现存在冲突。注意，主从复制场景下，只有一个主节点处理写请求，所以不会出现这种情况。

#### 同步与异步冲突检测
在主从复制下，只有一个主节点，所以修改总是按先后顺序，不可能发生冲突。然而在多主复制下，修改是先成功返回，然后再异步同步到其它主节点的。

理论上也可以做同步的冲突检测，但这样就失去了多主复制的意义：多个主节点可以独立接受写请求。
#### 避免冲突
处理冲突最理想的策略是避免冲突，即如果应用层可以保证对特定记录的写请求总是通过同一个主节点，这样就不会发生写冲突。这是最推荐的首选方案。

但是，有时可能需要改变事先指定的主节点，例如某主节点发生故障。此时，已经无法避免冲突。
#### 收敛于一致状态
对于多主复制，发生冲突时，无法决定谁的结果更正确。而在复制模型下，每个节点都是同一份数据的副本，所以这些副本必须最终收敛到相同的状态。

使多个冲突的写入收敛有以下方法：
* 丢弃某一个写入。例如给每个写入分配唯一的 ID，然后挑选最高 ID 的写入作为胜利者。或者为每个副本分配唯一的 ID，并指定副本的优先级。虽然这种方法很流行，但是很容易造成数据丢失，牺牲了数据的持久性。
* 以某种方式将值合并在一起。可以是数据库系统自动合并。也可以把冲突报告出去，然后依靠应用层逻辑事后解决，类似于 git merge conflict。
##### 自定义冲突解决逻辑
解决冲突最合适的方式可能还是依靠应用层，所以大多数多主复制模型都支持用户编写应用代码来解决冲突。可以在写入时或者读取时执行这些代码逻辑，两者没有明显的优劣之分。

注意，冲突解决通常用于单个行或文档，而不是整个事务。一个事务里的多个写请求仍然是分开考虑来解决冲突。
#### 什么是冲突？
有些冲突是显然的。例如前面的，两个并发写修改了同一个 key 的值。其它形式的冲突则很微妙。例如数据库事务中的各种情形。我们将在第 7 章看到更多的冲突示例，在第 12 章讨论检测和解决冲突的可扩展的方法。

### pipeline 传播的拓扑结构
复制的拓扑结构描述了写请求从一个节点传播到其它节点的通信路径。

最常见的拓扑结构是 all-to-all，这是一个完全图。此外，还有环形拓扑（一个接一个），星形结构（一个节点位于中间）。星形结构还可以推广到树状结构。

环形和星形的问题是，如果一个节点发生了故障，所有依赖于这个节点的复制将无法完成。可以通过重新配置来排除掉故障节点，但这通常需要手动完成。而对于链接更密集的拓扑，消息有多种传播路径，避免了单点故障，因此具有更好的容错性。

但是另一方面，存在多种路径传播时，可能发生后发生的写入走了更短的路径，从而导致复制日志之间的覆盖。这里涉及到一个因果关系问题，类似于前面的[前缀一致读](#前缀一致读)：更新操作一定是依赖于先前完成的插入，因此要确保所有节点一定要先接收插入日志，然后再处理更新。参见本章的[检测并发写](#检测并发写)。

## 无主节点复制
主从复制和多主复制，都是基于这样的**核心思路**：客户端先向某个节点（即主节点）发送写请求，然后数据库系统负责将写请求复制到其它副本。由主节点决定写操作的顺序。

而无主节点复制则是**不同的思路**：选择放弃主节点，任何节点都可以接受写请求。对于某些实现，客户端直接将写请求发送到多个副本，而在其它一些实现中，由一个协调者节点代表客户端进行写入。然而，协调者不负责维护写入顺序。

### 节点失效时的写入
假设一个三副本数据库，有一个副本不可用。则用户将写请求并行发送到三个副本，此时有两个可以成功返回，则认为写入成功。如果此时失效的副本重新上线，客户端读取时，可能从这个节点读取到过期的数据。为了解决此问题，客户端读取时，不是从一个副本读取，而是并行地发送到多个副本。客户端会得到多个返回，可以通过版本号技术来决定哪个值更新。
#### 失效节点恢复后的副本修复
当一个失效节点重新上线时，它如何赶上中间错过的那些请求呢？此时已经没有主节点可以负责把复制日志发送给从节点。Dynamo 风格的数据存储系统经常使用以下两种机制：
* 读时修复
  * 客户端读取时，可以检测到过期的返回值，可以将新值复制到该副本。这种方法适合那些被频繁读取的场景。
* 反熵
  * 用后台线程不断查找副本之间数据的差异，将任何缺少的数据从一个副本复制到另一个副本。这是一个反熵过程。与主从复制不同，这种方式会引入明显的同步滞后。

当缺少反熵支持时，由于读时修复只在发生读取时才执行修复，所以很少读取的数据可能不会得到修复，从而降低了写的持久性。

#### 读写 quorum
如果有 n 个副本，写入需要 w 个节点确认，读取必须至少查询 r 个节点，则只要 $w + r > n$，读取的节点中一定会包含最新值。这被叫做法定票数读和法定票数写。

参数 n, w 和 r 通常是可以配置的。可以根据自己的需求灵活配置。例如，对于读多写少的负载，设置 w = n 和 r = 1 比较合适。

仲裁条件$w + r > n$ 定义了系统可容忍的失效节点数。如果可用节点数小于所需的 w 或 r，则写入或读取就会返回错误。通常，读取和写入操作总是并行发送到所有的 n 个副本。参数 w 和 r 只是决定要等待的节点数。

#### quorum 一致性的局限
即使在$w + r > n$的情况下，也存在旧值被返回的边界情况。可能的情况包括：
* 宽松的 quorum
* 如果某些副本上写入成功，某些副本上写入失败，且总的成功副本数小于 w，那些已成功的副本上不会做回滚。这意味着尽管写操作失败，但是后续的读操作仍可能返回新值。
* 等等

因此，虽然 quorum 设计上似乎可以保证读取最新值，但现实情况却往往更加复杂。我们**建议**最好不要把参数 w 和 r 视为绝对的保证，而是一种灵活可调的读取新值的概率。

例如，这里通常无法得到本章前面所罗列的一致性保证。如果确实需要更强的保证，需要考虑事务与共识问题。参考第 7 章和第 9 章。

#### 宽松的 quorum
配置适当的 quorum 可以容忍某些节点故障而不需要做故障恢复。对于需要高可用和低延迟的场景来说，这尤其有用。

但是，由于网络问题，客户端有时会无法满屋 quorum 要求。在一个大规模集群中，客户可能在网络中断期间还能连接到某些数据库节点，但这些节点又无法满足 quorum 要求。此时，面临一个选择：
* 是将错误明确地返回给客户端
* 或者说，接受该写请求，只是将它们暂时写入一些可访问的节点中。注意，这些节点并不在 n 个节点集合中。

后一种方式称为宽松的 quorum：写入和读取仍然需要满足$w + r > n$，但是可以包含不在先前指定的 n 个节点中的节点。一旦网络问题得到解决，临时节点需要把接收到的写入全部发送到原始主节点上。这就是所谓的**数据回传** (hinted handoff)。

可以看出，宽松的 quorum 对提高写入可用性特别有用：只要有任何 w 个节点在线，就可以处理写入。这也导致可能读取到旧值。因此，宽松的 quorum 并不是为了得到什么一致性，而是为了数据持久性的一个保证措施。

### 检测并发写
Dynamo 风格的数据库允许多个客户端对相同的主键同时发起写操作，即使采用严格的 quorum 机制也可能发生写冲突。此外，由于读时修复或者数据回传也会导致并发写冲突。

在多主复制一节已经说明了如何解决冲突，这里继续说明如何检测冲突。首先，只有并发写才可能导致冲突；其次是，并发写不必然导致冲突。

#### happens-before 关系和并发
首先看怎么检测并发写。

什么是并发？如果 B 知道 A，则称操作 A 在操作 B 之前发生。这里定义了一个偏序关系。如果 A 不在 B 之前，B 也不在 A 之前，则 A 和 B 是并发操作。因此，我们只需要追踪这种偏序关系，则如何两个操作没有父子关系，则是并发操作。这里的 happens-before 关系让我想起了 Java 内存模型。

#### 确定前后关系
我们来看一个确定操作并发性的算法。依据主要是靠对比操作的版本号，而并不需要解释新旧值本身。流程如下：
* 服务器为每个主键维护一个版本号。每当发生了写入时，递增版本号，并与写入的值一起保存。
* 当客户端读取时，服务器返回所有当前的值（可能有多个，见下面的 siblings）和最新的版本号。
* 当客户端写入时，需要携带之前看到过的版本号。
* 当服务端收到带有特定版本号的写入时，覆盖该版本号或更低版本号的值，但必须保存更高版本号的所有值（因为这些值属于并发）。

简而言之，这里通过写请求之前见到过的版本号，从而确定了写请求的偏序关系，这是一个有向无环图。

#### 合并同时写入的值
上述算法只是追踪了因果关系，只能检测出可能发生冲突的并发写，并不能自动解决冲突。在上面的第二步中，如果服务器返回了多个并发的值，则客户端需要合并这些值。这些并发值称为 siblings （兄弟）。

本质上，合并多个值就是如何解决冲突。可以用最后写入获胜 (LWW)，也可以是其它自定义的合理的行为。

#### 版本向量
当只有一个副本时，只需要维护一个版本号。当有多个副本时，每个副本都有一个版本号，合起来就是一个版本向量。版本向量和版本号的工作方式完全类似。每个副本在处理写入时增加自己的版本号，并且跟踪从其它副本看到的版本号。

## 小结
本章探讨了复制相关的话题。

有三种多副本方案：
* 主从复制
  * 只有一个主节点，其它都是从节点。从节点只可以读，只有主节点可以写。
* 多主复制
  * 有多个主节点，每个主节点同时作为其它主节点的从节点
* 无主复制
  * 客户端将写请求发送到多个节点上，读取时从多个节点上并行读取

这三种方案都会有复制滞后的问题。复制滞后带来了三个一致性相关的问题：
* 写后读一致性
* 单调读
* 前缀一致读

此外，多主复制和无主复制还会有并发写操作引起的冲突。我们必须检测并发写，并合并并发写入的值。